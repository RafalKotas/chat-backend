# ðŸ“˜ 9. Tests - Architecture, Conventions & Annotations

This document explains:
- How tests are structured in the project
- Why specific annotations are used
- How test layers are separated
- Best practices for writing tests
- Example patterns (given / when / then)
- Security config overrides for isolated testing

---

## 6.1 Philosophy of Testing

Out last architecture follows three principles

### âœ” Fast

Test must run quickly (WebMvcTest boots only the web layer).

### âœ” Isolated

Each layer is tested separately:
- Controllers â†’ WebMvcTest
- Services â†’ plain Mockito
- Repositories â†’ Testcontainers (future)

### âœ” Predictable

No real security filters or repositories unless explicitly needed.

---

## 6.2 Test Layers

### 1. Unit Tests

Pure Java tests without Spring:
- DTOs
- small utility logic
- equals/hashCode
- simple mapping functions

Tools
- JUnit 5
- AssertJ

---

### 2. Web Layer Tests (Controllers)

We use:

```java
@WebMvcTest(SomeController.class)
```

This loads:
- only Spring MVC
- only the tested controller
- MockMvc For HTTP simulation
- no DB
- no services (unless mocked)

Then we mock dependencies:
```java
@MockitoBean
ChatService chatService;
```

This ensures controller behavior is isolated from business logic.

---

### 3. Service Tests

Here we test:
- business logic
- repository integration (mocked for now)
- input validation

We use plain

```java
@ExtendWith(MockitoExtension.class)
```

and manually mock repositories.

---

## 6.3 Important Annotations Explained
ðŸ”¹ `@WebMvcTest`
Loads ONLY:
- DispatcherServlet
- MVC config
- Controller under test

Does NOT load:
- repositories
- services
- WebSocket config
- security (unless addFilters=true)

---

ðŸ”¹ `@AutoConfigureMockMvc(addFilters = false)`

Why?

Because otherwise Spring Security would block all non-authenticated requests.<br>
We disable filters to focus ONLY on controller logic.

---

ðŸ”¹ `@MockitoBean`

Adds a mock to Spring's application context.

This is required because:

`@WebMvcTest` creates a Spring context â†’ dependencies of controllers must exist in that context.

---

ðŸ”¹ `@Import(MockedSecurityConfig.class)`

Our project has security enabled globally.

So we override it with a "no-op" mock config to avoid 401 during tests.

---

## GIVEN / WHEN / THEN Pattern

Every test follows:

### âœ” GIVEN

setup input & mocked behavior

### âœ” WHEN

execute action (MockMvc / method call)

### âœ” THEN

assert output & interactions

Example:

```java
// given
UUID id = UUID.randomUUID();
when(service.getChat(id)).thenReturn(chat);

// when
mockMvc.perform(get("/api/chats/" + id))

// then
.andExpect(status().isOk());
verify(service).getChat(id);
```

---

## 6.5 Controller Testing Rules

### Rule 1: Never call service directly

Use MockMvc for readability & realism.

### Rule 2: Assert both

âœ” HTTP response

âœ” interaction with service

### Rule 3: Always mock service responses

--- 

## 6.6 Common Test Utilities

### JSON bodies

Use compact multi-line strings inside MockMvc calls.

### UUIDs

Generate random per test to avoid value bleed.

---

## 6.7 What We Do NOT Do in WebMvcTest
- No DB
- No MessageBroker
- No WebSocket tests here
- No full security tests
- No context-heavy beans

These reduce test speed & isolation.

---

## 6.8 Future Improvements

Later we will add:
- Testcontainers for repository tests
- Security integration tests with real JWT
- WebSocket tests (Spring StompClient)

---

## âœ” Summary

The test setup ensures:
- predictable isolated execution
- clean boundaries between layers
- ultra-fast web tests
- no interference from security or the DB

This gives us a solid testing foundation for both REST and WebSocket modules.