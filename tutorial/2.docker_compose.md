# docker-compose.yml - Infrastructure Setup

This document explains how Docker Compose is used to run the backend infrastructure locally.

---

## ğŸ“ Location

```
tools/docker/docker-compose.yml
```

---

## â“ What is Docker Compose?

Docker Compose allows us to define and run **multiple containers** as a single environment.

In this project, it is used to run:
- PostgreSQL (database)
- pgAdmin (database administration UI)

---

## ğŸ§± Services Overview

```yaml
services:
  postgres:
  pgadmin:
```

Each service represents one container.

---

## ğŸ˜ PostgreSQL Service

```yaml
postgres:
  image: postgres:16
  container_name: chat-postgres
  environment:
    POSTGRES_DB: chatdb
    POSTGRES_USER: chatuser
    POSTGRES_PASSWORD: chatpass
```

### Explanation:
- **image** - official PostgreSQL image
- **POSTGRES_DB** - database created at startup
- **POSTGRES_USER / PASSWORD** - database credentials

---

## ğŸ”Œ Ports and Volumes

```yaml
ports:
  - "5432:5432"
volumes:
  - chat_postgres_data:/var/lib/postgresql/data
```

### ğŸ“¡ Port Mapping - how it actually works
The entry:
```
"5432:5432"
```
means:
- **left side (`5432`)** â†’ your host machine (Windows/macOS/Linux)
- **right side (`5432`)** â†’ inside the Docker container (PostgreSQL's internal port)

So when your backend connects to:
```
jdbc:postgresql://localhost:5432/chatdb
```

Docker forwards this request into the container.
This is why you can treat PostgreSQL as if it were installed locally - Docker handles the routing.

If the left side were different, e.g. `15432:5432`, you would connect like this:
```
jdbc:posgtesql://localhost:15432/chatdb
```

---

### ğŸ’¾ Volume Mapping - persisting data
```
chat_posgres_data:/var/lib/postgresq;/data
```
This connects:
- **host volume (`chat_postgres_data`)** â†’ stored outside the container
- **container folder (`/var/lib/postgresql/data`) â†’ where PostgreSQL keeps actual DB files

Without this volume:
- every `docker compose down` would DELETE your databasae
- every restart would create a fresh empty DB

With the volume:
- your data survives restarts
- survives container rebuilds
- survives updates of the PostgreSQL image

---

## â¤ï¸ Health Check

```yaml
healthcheck:
  test: ["CMD-SHELL", "pg_isready - U chatuser"]
  interval: 5s
  timeout: 5s
  retries: 5
```

### What this means - line by line
- **`test: ["CMD-SHELL", ...]`** - tells Docker to run the command inside a shell.
- **`pg_isready -U chatuser`** - checks if PostgreSQL is ready to accept connections.
- **`interval`** - check runs every 5 seconds.
- **`timeout`** - check must complete within 5 seconds.
- **`retries: 5`** - after 5 failures the container is marked as unhealthy.

This ensures PostgreSQL is fully ready before other services depend on it.

---

## ğŸ§­ pgAdmin Service

```yaml
pgadmin:
  image: dpage/pgadmin4:8
  ports:
    - "5050:80"
```

pgAdmin is available at:
```
http://localhost:5050
```

It provides a graphical interface to inspect databases, tables, and data.

---

## â–¶ Running the Environment

Start containers:
```bash
docker compose -f /tools/docker/docker-compose.yml -p chat up -d
```

Stop containers:
```bash
docker compose -f /tools/docker/docker-compose.yml -p chat down
```

---

## âœ… Result

With Docker Compose running:
- PostgreSQL is available on port 5432
- pgAdmin is available in the browser
- Spring Boot can connect to the database reliably

---

This setup will later be extended with Redis and other services.