# ğŸ“˜ 4.3 - JWT Authentication Filter

### *JwtAuthenticationFilter - Request Authentication Explained*

This document explains the role, flow, and internal logic of `JwtAuthenticationFilter`, which provides 
**stateless authentication** using JWT tokens in the ChatApp backend.

--- 

## 1. Purpose of the Filter
`JwtAuthenticationFilter` is a `OncePerRequestFilter`, meaning:
- it runs **once per each incoming HTTP request**
- it decides whether the request contains a valid JWT token
- if yes â†’ it authenticates the user
- if not â†’ request continues **unauthenticated**

This filter is the key part of the security chain, enabling:

âœ” stateless authentication

âœ” no server-side sessions

âœ” automatic injection of authenticated principal into Spring SecurityContext

--- 

## 2. Authentication Flow Overview

Below is the full life-cycle of request authentication:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Incoming HTTP Request â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
     Check Authorization header
               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      â”‚
 header missing     header present,
 or not "Bearer" â†’  extract JWT
    â”‚                      â”‚
    â–¼                      â–¼
 allow request       validate token
 unauthenticated        (JwtUtils)
    â”‚                      â”‚
    â–¼                      â”‚
 continue filter chain â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚ valid token? â”‚
                       â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â–¼                                â–¼
   continue unauthenticated      load UserDetails (DB lookup)
                                       â”‚
                                       â–¼
                              build Authentication object
                                       â”‚
                                       â–¼
                        store authentication in SecurityContext
                                       â”‚
                                       â–¼
                             continue filter chain

```

---

## 3. Annotated Source Code

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtils jwtUtils;
    private final CustomUserDetailsService customUserDetailsService;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        final String header = request.getHeader("Authorization");

        if (header == null || !header.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        final String token = header.substring(7);

        if (!jwtUtils.isValid(token)) {
            log.debug("Invalid JWT token");
            filterChain.doFilter(request, response);
            return;
        }

        final String username = jwtUtils.extractUserName(token);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            try {
                UserDetails userDetails =
                        customUserDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );

                authentication.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authentication);

            } catch (UsernameNotFoundException e) {
                filterChain.doFilter(request, response);
                return;
            }
        }

        filterChain.doFilter(request, response);
    }
}

```

---

## 4. Step-by-step Behavior

### Step 1 - Read Authorization header

If missing or malformed â†’ request proceeds unauthenticated.

### Step 2 - Extract JWT

Expected format:

```
Authorization: Bearer <JWT_TOKEN>
```

### Step 3 - Validate Token

Delegated to:
- signature verification
- expiration check
- structural integrity

Implemented in `JwtUtils.isValid()`.

### Step 4 - Extract Subject (username)

Token contains `.setSubject(username)` â†’ used as login key.

### Step 5 - Load UserDetails

We grab the authenticated principal using:

```java
customUserDetailsService.loadUserByUsername(username)
```

This loads password hash + roles.

### Step 6 - Store Authentication in SecurityContext

This allows endpoint controllers to access:
- `@AuthenticationPrincipal`
- `SecurityContextHolder.getContext().getAuthentication()`
- role-based access annotations (`@PreAuthorize`)

---

## 5. Why We Authenticate Only if Context Is Empty?

This condition prevents re-authentication:

```java
SecurityContextHolder.getContext().getAuthentication() == null
```

Spring may pre-populate the context during internal mechanisms.

Double-authentication would be:
- unnecesary
- slower
- risky

---

## 6. Why Exceptions Are Not Thrown?

Invalid token â†’  request is allowed to continue, but **unauthenticated**.

Reason:
- throwing exceptions here would break endpoint handlers
- authentication failure â‰  request failure
- e.g., a resource might be public, but authentication optional

Unauthorized access is handled **later** by Spring's access rules in `SecurityConfig`.

--- 

## 7. Interactions with SecurityConfig

The filter is registered in `SecurityFilterChain`:
- before `UsernamePasswordAuthenticationFilter`
- on every request except `/api/auth/**`

Thanks to that:
- login & registration bypass JWT check
- all other endpoints require authentication

---

## 8. Example Requests

### Successful request with token

```
GET /api/users/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR...
```

---

### Request without token

```
GET /api/users/me
```

Response â†’ `403 Forbidden` (security layer denies access)

---

### Request with invalid token

```
Authorization: Bearer INVALIDx.TOKEN.yyy
```

Filter logs:

```
Invalid JWT token
```

But **does NOT throw** - final access check denies access if endpoint requires auth.

--- 

### 9. Common Pitfalls & Fixes

âœ” Token prefix case sensitivity

Only `"Bearer "` is accepted â€” no lowercase, no extra spaces.

âœ” Prevent NPE on substring

Moved to:

```java
final String header = request.getHeader("Authorization");
if (header == null || !header.startsWith("Bearer ")) ...
```

âœ” Expired token is treated as invalid

`jwtUtils.isValid()` catches exception and return `false`.

âœ” Avoiding infinite loops

Filter always calls `filterChain.doFilter`.

--- 

## 10. Summary

`JwtAuthenticationFilter` is responsible for:
- extracting JWT from headers
- validating the token
- converting token â†’ authenticated user
- placing authentication in SecurityContext
- allowing unauthenticated request to proceed if token is missing/invalid

It is the backbone of **stateless authentication** in the ChatApp backend.