# 4.6. AuthService Documentation

## Overview

`AuthService` is the central business layer responsible for handling:
- user registration
- user authentication
- JWT token generation

This service acts as the bridge between the controllers, security infrastructure, and persistence layer
(`UserRepository`).

It ensures that authentication logic is isolated from HTTP and routing concerns.

--- 

## Dependecies

```java
private final AuthenticationManager authenticationManager;
private final PasswordEncoder passwordEncoder;
private final JwtUtils jwtUtils;
private final UserRepository userRepository;
```

### AuthenticationManager

Handles authentication attempts using Spring Security's authentication providers.

### PasswordEncoder

Used to hash user passwords before persisting them.

### JwtUtils

Generated and validates JWT tokens.

### UserRepository

Performs CRUD operations on `User` entitites.

---

## Method: `register(RegisterRequest registerRequest`

### Purpose

Creates a new `User` in the system and returns a `RegisterResponse`.

--- 

### Flow

1. Convert the incoming DTO (`RegisterRequest`) into a `User` entity.
2. Securely hash the password using `PasswordEncoder`.
3. Persist the entity using `UserRepository`
4. Return a DTO (`RegisterResponse`) containing:
- user ID
- email
- username

---

## Important Details

### Password hashing

Password are **never stored in plain text**.

```java
passwordEncoder.encode(registerRequest.password())
```

This ensures security best practices and prevents credential leakage.

--- 

### Uniqueness handling

`AuthService` itself does **not** check whether:
- email is already taken,
- username already exists.

This validation is expected to be handled by:
- database constraints (unique email/username)
- exception mapping inside `GlobalExceptionHandler`.

---

### Success Response Example

```json
{
  "id": "df201620-ea52-4fc4-9569-a4ac028e888f",
  "email": "john@mail.com",
  "username": "johnny"
}
```

| Reason                      | Type                                  | Notes                                                 |
|:----------------------------|:--------------------------------------|:------------------------------------------------------|
| Unique constraint violation | 409 / DataIntegrityViolationException | Email/username already exists                         |
| PasswordEncoder failure     | 500                                   | Should never happen but is possible                   |
| Invalid DTO                 | 400                                   | Handled before service method via validation          |
| Account disabled            | 403                                   | If business logic enforces it                         |
| Token generation failure    | 500                                   | Internal server error                                 |

--- 

## Method: `login(LoginRequest loginRequest`

### Purpose

Authenticates a user via Spring Security and issues a JWT token.

--- 

### Flow

1. AuthenticationManager attempts authentication using:
```java
new UsernamePasswordAuthenticationToken(
    loginRequest.username(),
    loginRequest.password()
)
```
2. If authentication **fails**, Spring Security throws an exception:
- `BadCredentialsException`
- handled by `AuthenticationEntryPointImpl`.
3. If authentication succeeds:
- Spring Security returns an `Authentication` object.
- Username is extracted with `authentication.getName()`.
- Token is generated via `jwtUtils.generateToken(username)`
4. A `LoginResponse` is returned.

--- 

## Security Notes

### ✔ Credentials do not leave the method
The password is only passed to Spring Security for verification.

### ✔ Authentication is delegated
AuthService does not verify passwords manually.

### ✔ Token generation isolated
JwtUtils ensures standard tokenization rules.

### ✔ Returned token is prefixed with "Bearer" automatically
Because the constructor does this in `LoginResponse`.

--- 

## Success Response Example
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR...",
  "tokenType": "Bearer"
}
```

---

## Failure Scenarios

| Error                      | HTTP Code | Description                           |
|:---------------------------|:----------|:--------------------------------------|
| Invalid username/password  | 401       | Thrown by AuthenticationManager       |
| Locked/disabled account    | 403       | If UserDetails specifies restrictions |
| JWT generation failure     | 500       | Internal server problems              |

---

## Authentication Flow Diagram

```
        ┌──────────────┐
        │ LoginRequest │
        └───────┬──────┘
                │
                ▼
┌──────────────────────────────────────────────┐
│     AuthenticationManager.authenticate()     │
└────────────────┬─────────────────────────────┘
                 │ success
                 ▼
        Extract authenticated username
                 │
                 ▼
     JwtUtils.generateToken(username)
                 │
                 ▼
         Return LoginResponse
```

---

## DTO Responsibilities

`RegisterRequest`
- contains user registration data
- validated before reaching service (via annotations)

`RegisterResponse`
- returned after successful registration
- contains non-sensitive data only

`LoginRequest`
- contains credentials for authentication
- validation ensures neither field is null/blank

`LoginResponse`
- wraps JWT token
- automatically populates `Bearer` prefix

---

## Why Logic is Kept in AuthService (Not Controller)?
✔ controllers must remain thin

✔ easier testing (AuthService is unit-test–friendly)

✔ promotes separation of concerns

✔ supports reusability (e.g. CLI authentication, background jobs)

✔ keeps controllers clean and avoids duplication

---

## Testability Notes
AuthService is decoupled from Spring MVC and highly testable:
- Mocking AuthenticationManager
- Mocking PasswordEncoder
- Mocking JwtUtils
- Mocking UserRepository

This allows isolated verification of:
- entity creation
- password hashing
- authentication attempts
- JWT generation

---

## Examples for Developers

### Register user (curl)

```powershell
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
        "email":"mark@mail.com",
        "password":"Abc123!",
        "username":"mark",
        "firstName":"Mark",
        "lastName":"Something"
      }'
```

### Login user (curl)

```powershell
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
        "username":"mark",
        "password":"Abc123!"
      }'
```

