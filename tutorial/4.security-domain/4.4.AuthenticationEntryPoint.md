# 4.4 AuthenticationEntryPoint

## Overview

`AuthenticationEntryPointImpl` is a Spring Security component responsible for handling authentication errors within the 
application.

Whenever a client attempts to access a protected resource **without valid credentials**, such as:
- missing JWT token,
- invalid or malformed JWT,
- expired token,
- or when the user is not authenticated,

Spring Security invokes this entry point to return a standardized error response.

By default, Spring Security returns an HTML error page, which is not suitable for a REST API. 

`AuthenticationEntryPointImpl` converts these errors into a clean JSON structure.

---

## Role in the Security Architecture

`AuthenticationEntryPointImpl`:
- intercepts authentication failures thrown anywhere in the security filter chain,
- returns an HTTP **401 Unauthorized** response,
- ensures consistent JSON error formatting,
- works alongside `JwtAuthenticationFilter`,
- is automatically injected into the security configuration via `@Component`.

This ensures that any authentication-related failure leads to a proper REST-compliant response.

---

## Response Format

A typical error response produced by this entry point looks like:

```json
{
  "status": 401,
  "error": "Unauthorized",
  "message": "...",
  "path": "/api/example"
}
```

### Fields

| Field     |      Type |                            Description |
|-----------|----------:|---------------------------------------:|
| `status`  |    number |   Always `401` for unauthorized access |
| `error`   |    string |   Short description (`"Unauthorized"`) |
| `message` |    string | Details from `AuthenticationException` |
| `path`     |    string |  Request path that triggered the error |

---

### Source Code

```java
package com.chatapp.chat.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException, ServletException {

        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", 401);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
```

---

## When is AuthenticationEntryPoint triggered?

| Scenario                                                              |                          Behavior |
|-----------------------------------------------------------------------|----------------------------------:|
| No `Authorization` header                                             |                       Returns 401 |
| Token does not start with `"Bearer"`                                  |                       Returns 401 |
| Token is expired                                                      | Returns 401 with detailed message |
| Token signature is invalid                                            |                       Returns 401 |
| User attempts to access protected endpoint without being logged<br>in |                       Returns 401 |

`JwtAuthenticationFilter` may throw exceptions that propagate into this entry point, ensuring unified handling.

--- 

## Integration With SecurityConfig

`AuthenticationEntryPointImpl` is plugged into security configuration as follows:

```java
http
    .exceptionHandling(ex -> ex
        .authenticationEntryPoint(authenticationEntryPoint)
    );
```

This guarantees REST-style error responses across the entire application.

---

## Related Components
- **JwtAuthenticationFilter** - extracts and validates JWT tokens
- **JwtUtils** - token generation & validation logic
- **SecurityConfig** - master configuration for authentication and authorization

--- 

## Testing Considerations

You can test this component by triggering unauthorized access, e.g.:
- calling a protected endpoint without authentication,
- mocking an `AuthenticationException`,
- simulating an expired or malformed token.

Expected JSON response:

```json
{
  "status": 401,
  "error": "Unauthorized",
  "message": "Full authentication is required to access this resource",
  "path": "/api/user/me"
}
```

---

# Why We Do Not Handle Authentication Errors in GlobalExceptionHandler 

Spring provides **two separate exception-handling mechanisms**, depending on where is the request lifecycle an error 
occurs. 

Understanding this distinction is crucial to knowing **why authentication errors cannot be handled in** 
`@ControllerAdvice` and why we use `AuthenticationEntryPoint` instead.

---

## 1. Exceptions Handled by Spring MVC (`@ControllerAdvice`)

A `GlobalExceptionHandler` using `@ControllerAdvice` is capable of intercepting exceptions that:
- occur **after the request reaches a controller**,
- are thrown within MVC processing (argument validation, business logic, service layer),
- belong to application-level workflows.

Examples handled by `@ControllerAdvice`:
- `MethodArgumentNotValidException`
- Custom domain exceptions (e.g.m `UserAlreadyExistsException`)
- Validation failures
- Logic errors inside controllers

However, **authentication happens long before the controller layer is invoked.**

`@ControllerAdvice` does **not** apply to filters in the Spring Security filter chain.

--- 

## 2. Exceptions Handled by Spring Security

Spring Security processes **every incoming request before it reaches any controller.**

This includes:
- checking authentication (JWT, session, basic auth, etc.),
- verifying request headers, 
- validating tokens,
- checking roles / authorities.

Errors occurring here never reach the MVC exception-handling layer.

Spring Security provides its own dedicated handlers:

| Error Type                         | Example                                       | Handler                    |
|:-----------------------------------|:----------------------------------------------|:---------------------------|
| **Unauthenticated (401)**          | Missing JWT, expired token, invalid signature | `AuthenticationEntryPoint` |
| **Authenticated but Unauthorized** | User logged in but lacks permissions          | `AccessDeniedHandler`      |

These errors are **swallowed** in the security layer and never propagated to `@ControllerAdvice`.

---

## Why AuthenticationEntryPoint is Required

Without a custom `AuthenticationEntryPoint`, Spring Security returns its default HTML error page or a bare 
"Unauthorized" string — which is unacceptable for REST APIs.

A custom entry point allows us to:
- define a consistent JSON error response for 401 errors,
- override Spring Security's default HTML responses,
- ensure clients receive structured error information,
- handle token-related issues such as expiration, invalid signature, missing header, wrong prefix, etc.

Furthermore:

> **Spring Security does not forward authentication failures to Spring MVC**, so a `ControllerAdvice` cannot catch them.

This architectural separation is intentional to ensure that security concerns remain isolated.

--- 

## Could We Technically Use GlobalExceptionHandler for Authentication Errors?

Only in very limited scenarios:

`@ControllerAdvice` can handle exceptions **only after authentication succeeds** and request execution reaches the 
controller.

Thus, it *can* handle:
- domain errors (`UserNotFoundException`)
- validation failures
- internal server errors triggered inside controllers

But it *cannot* handle:
- missing Authorization header
- malformed or expired JWT
- invalid token prefix (`Bearer abc...`)
- signature verification failure
- authentication failures for anonymous users
- authorization failures (403)

These are exclusively handled by Spring Security.

---

## Summary

| Mechanism                                           |                                                When it Runs |                                    What It Handles |                                      Why We Need It |
|-----------------------------------------------------|------------------------------------------------------------:|---------------------------------------------------:|----------------------------------------------------:|
| **AuthenticationEntryPoint**                        | Before request enters controller<br>(Security Filter Chain) |                      Authentication failures (401) |         Allows JSON responses for token/auth issues |
| **AccessDeniedHandler**                             |                     After authentication, before controller |                       Authorization failures (403) |                    Handles role-based access errors |
| **GlobalExceptionHandler**<br>(`@ControllerAdvice`) |                                 After controller is invoked | Validation, business logic errors, internal errors | Provides structured JSON for application exceptions |

This is why the project uses:
- **AuthenticationEntryPoint** → for authentication errors
- **ControllerAdvice** → for application/business errors

Following Spring Security best practices.

--- 

