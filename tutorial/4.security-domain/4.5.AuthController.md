# üìÑ 4.5. AuthController Documentation

## Overview

`AuthController` is the Rest controller responsible for handling user authentication and registration requests.

It exposes two HTTP endpoints:
- `POST /api/auth/register` - user registration
- `POST /api/auth/login` - user authentication and JWT token issuance

The controller follows **thin-controller, thick-service** architecture: all business logic is delegated to `AuthService`,
while the controller remains responsible only for request parsing and response formatting.

--- 
## Endpoints

## 1. POST `/api/auth/register`

### Method signature

```java
@PostMapping("/register")
@ResponseStatus(HttpStatus.CREATED)
public RegisterResponse register(@RequestBody RegisterRequest registerRequest)
```

### Request body

The request expects a `RegisterRequest`:

```json
{
  "email": "example@mail.com",
  "password": "StrongPassword123",
  "username": "john_doe",
  "firstName": "John",
  "lastName": "Doe"
}
```

### ‚ùó About `@RequestBody`

Spring attempts to deserialize JSON ‚Üí `RegisterRequest`.

If JSON is **correct**, Spring injects a populated object into the method.

If JSON is **malformed**, missing required fields, or cannot be parsed:
- Spring throws `HttpMessageNotReadableException`
- which is handled globally by `GlobalExceptionHandler`

If JSON is valid but fails **validation annotations** (e.g. `@NotBlank`):
- Spring throws `MethodArgumentNotValidException`
- also handled by GlobalExceptionHandler

‚úî No validation annotations are placed inside the controller ‚Äî all are inside DTOs.

### ‚ùó About @ResponseStatus(HttpStatus.CREATED)

This annotation forces the endpoint to return HTTP **201 Createed**, even if the return type is a simple object.

Without it, Spring would return **200 OK**.

This is a REST best practice:
**Registration creates a new resource ‚Üí status 201 is appropriate.**

### Successful Response

Example

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "example@mail.com",
  "username": "john_doe"
}
```

### Error Cases

| Error                   | Status |                                Reason |
|-------------------------|-------:|--------------------------------------:|
| Invalid JSON            |    400 |       Parsing failed (`@RequestBody`) |
| Validation errors       |    400 |               Failing DTO constraints |
| Email/username conflict |    409 | Depends on AuthService implementation |
| Internal server error   |    500 |                   Unexpected failures |

## 2. POST `/api/auth/login`

### Method signature

```java
@PostMapping("/login")
public LoginResponse login(@RequestBody LoginRequest loginRequest)
```

### Purpose

Authenticates a user and returns a JWT token wrapped inside `LoginResponse`.

### Request body

```json
{
  "username": "john_doe",
  "password": "StrongPassword123"
}
```

### ‚ùó Important details'
- Authentication is delegated to `AuthService.login()`
- If the username/password is correct ‚Üí JWT token is generated
- If incorrect ‚Üí Spring Security throws `BadCredentialsException`

This exception is handled by:
- `AuthenticationEntryPointImpl` for unauthenticated access
- `GlobalExceptionHandler` (if thrown from service explicitly)

### Successful Response
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiJ9...",
  "tokenType": "Bearer"
}
```

| Error                     | Status | Reason                                  |
|:--------------------------|:-------|:----------------------------------------|
| Invalid JSON              | 400    | Bad request body                        |
| Missing username/password | 400    | DTO validation rules                    |
| Invalid credentials       | 401    | Handled by AuthenticationEntryPointImpl |
| Account disabled          | 403    | If business logic enforces it           |
| Token generation failure  | 500    | Internal server error                   |

--- 

## Responsibilities of AuthController
‚úî Convert HTTP request ‚Üí `RegisterRequest` / `LoginRequest`

‚úî Return appropriate HTTP status codes

‚úî Delegate business logic to AuthService

‚úî Do NOT contain any authentication/validation/business logic inside the controller

‚úî Keep endpoints small and focused

‚úî Allow Spring Security to handle authentication exceptions

---

## Why No Validation Annotations in Controller?

Spring encourages:
- DTO-level validation(`@NotBlank`, `@Email`, etc.)
- automatic exception handling through `@ControllerAdvice`

This keeps controller code clean and makes validation reusable.

---

## Interaction Diagram

```
Client ‚Üí AuthController ‚Üí AuthService ‚Üí UserRepository
                      ‚Üò JwtUtils ‚Üí Token
```

---

## Security  Notes
- `/api/auth/register` and `/api/auth/login` are explicitly permitted in `SecurityConfig`
- No authentication required to access these endpoints
- Protection against brute-force attacks should be implemented externally (e.g., rate limiting, Captcha)
- JSON parsing errors are handled gracefully and not considered security vulnerabilities
- `AuthenticationEntryPointImpl` ensures consistent 401 JSON responses

---

## Example Curl Requests

### Register

```
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@mail.com","password":"Abc123!","username":"tester","firstName":"A","lastName":"B"}'
```

### Login

```
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"tester","password":"Abc123!"}'
```

