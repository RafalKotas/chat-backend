# 4.3 - CustomUserDetailsService

This document explains the core responsibility of the `CustomUserDetailsService` class: loading application users into 
Spring Security's authentication system.

--- 

## 1. Purpose of UserDetailsService

Spring Security requires a way to **load user data** whenever authentication is performed.

This happens in two major cases:

### ① Username + Password authentication

During login (`/api/auth/login`) Spring calls:

```java
UserDetails loadUserByUsername(String username)
```

### ② JWT authentication

When processing `Authorization: Bearer <token>`, our `JwtAuthenticationFilter` extracts the username from JWT and again 
calls:

```java
customUserDetailsService.loadUserByUsername(email)
```

So Spring expects a **UserDetailsService implementation**, responsible for:
- looking up the user in the database
- converting it into a Spring Security `UserDetails` instance
- throwing `UsernameNotFoundException` when missing

--- 

## 2. Implementation

Below is the current implementation used in your project.

```java
package com.chatapp.chat.security;

import com.chatapp.chat.user.User;
import com.chatapp.chat.user.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {

        User user = userRepository.findByEmail(email)
                .orElseThrow(() ->
                        new UsernameNotFoundException("User not found: " + email)
                );

        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                user.getAuthorities()
        );
    }
}
```

---

## 3. How It Works Internally

### 3.1 During Login (/auth/login)

1. `AuthService.login()` calls `authenticationManager.authenticate(...)`
2. Spring Security invokes `loadUserByUsername(email)`
3. `CustomUserDetailsService` loads User from DB
4. Password is compared by `DaoAuthenticationProvider`
5. If valid → authentication succeeds
6. JWT token is generated and returned

#### Sequence Diagram:

```
Client → AuthController → AuthService → AuthenticationManager
AuthenticationManager → UserDetailsService.loadUserByUsername()
UserDetailsService → UserRepository → DB
DB → UserDetailsService → AuthenticationManager
AuthenticationManager → PasswordEncoder → OK
AuthService → JwtUtils.generateToken() → Client
```

### 3.2 During Requests with JWT

Example request:

```
Authorization: Bearer eyJhbGciOiJIUzI1...
```

Flow:
1. `JwtAuthenticationFilter` extract token
2. Validates using `JwtUtils.isValid(token)`
3. Extract subject (email)
4. Calls:
    ```java
    loadUserByUsername(email)
    ```
5. Creates an authenticated user in SecurityContext
6. Request proceeds as *authenticated*

--- 

## 4. Why not use your domain User directly?

Your domain model:

```java
public class User { ... }
```

Spring Security requires **UserDetails** implementation.

The built-in one is:

```java
org.springframework.security.core.userdetails.User
```

This class contains:
- username
- password
- authorities
- flags like accountLocked, enabled etc.

Domain objects **should not** leak into security infrastructure.

--- 

## 5. Error Handling

When no user exists:

```java
throw new UsernameNotFoundException("User not found: " + email);
```

This exception triggers:
- failed login (401)
- or failed JWT authentication (ignored, treated as anonymous)

--- 

## Integration With JWT

Your filter:

```java
UserDetails userDetails = customUserDetailsService.loadUserByUsername(email);
```

If successful:

```java
SecurityContextHolder.getContext().setAuthentication(authentication);
```

This tells Spring:
> "This request belongs to this user"

Without storing a session
- because JWT is stateless.

--- 

## 7. Possible Improvements

**✔ Add support for roles**

Map your enum `UserRole` → GrantedAuthority:

```java
new SimpleGrantedAuthority("ROLE_" + user.getRole().name())
```

**✔ Extract a custom UserDetails class**

If your domain gets more complex:

```java
public class AppUserDetails implements UserDetails { ... }
```

**✔ Add caching (optional)**
Spring supports caching user details for performance.

---

## 8. Summary 

`CustomUserDetailsService` is a **bridge** between:
- your **database user model**, and
- **Spring Security's authentication system**

It powers:
- login authentication
- JWT validation
- populating `SecurityContext`

It is a critical part of the authentication pipeline.

---




