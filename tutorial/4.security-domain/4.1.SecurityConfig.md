# ‚úÖ DOCUMENTATION SECTION ‚Äî SecurityConfig

## 4.1. Security Configuration (SecurityConfig)

`SecurityConfig` is the central configuration class that defines **how HTTP requests are secured**, which endpoints 
require authentication, and how Spring Security processes incoming requests.

This project uses **JWT-based authentication**, which means:
- the backend is **stateless**
- there is **no session**
- authentication is handled entirely via the `Authorization: Bearer <token>` header

Because of this, several default Spring Security mechanisms must be adjusted.

--- 

## üîí CSRF ‚Äî What It Is and Why We Disable It

### What is CSRF?

**CSRF (Cross-Site Request Forgery) is an attack where a malicious website forces a user's browser to send an 
authenticated request to another site.

It applies only when:

1. **Authentication is stored automatically in the browser**, typically:
    - session cookies
    - remember-me cookies
2. The server relies on those cookies to identify the user.

Then a malicious site can make your browser send:

```http request
POST https://bank.com/transfer
Cookie: SESSION=abc123
```

without your consent.

---

## ‚ùå Why JWT APIs disable CSRF

In a JWT-based API:
- The server **does not** store authentication state.
- The client **must manually** send the JWT token in the `Authorization` header.
- The browser will **never** attach the JWT automatically.

This means:

üëâ a third-party website **cannot** trigger an authenticated request

üëâ because it **does not have access to the Authorization header**

Therefore, **CSRF protection becomes unnecessary** and must be disabled:

```java
http.csrf(AbstractHttpConfigurer::disable);
```

### When *not* to disable CSRF

Do NOT disable CSRF when:

‚ùó you use traditional session-based login

‚ùó the server issues cookies used for authentication

‚ùó your frontend runs on the same domain and users log in normally

In this project - **JWT-only API** CSRF should remain disabled.

---

## üö¶ Request Authorization Rules

```java
http.authorizeHttpRequests(auth -> auth
        .requestMatchers(HttpMethod.POST, "/api/auth/login").permitAll()
        .requestMatchers(HttpMethod.POST, "/api/auth/register").permitAll()
        .anyRequest().authenticated()
);
```

### Explanation:

| Path                 | Method |                            Access |
|----------------------|-------:|----------------------------------:|
| `/api/auth/login`    |   POST |      ‚úî Public (anyone can log in) |
| `/api/auth/register` |   POST | ‚úî Public (new users can register) |
| Any other endpoint   |    Any |       üîí Requires valid JWT token |

This ensures:
- Anonymous users can only **register** or **log in**
- Every other request must include:

```
Authorization: Bearer <jwt>
```

Otherwise, Spring Security returns:

```
401 Unauthorized
```

--- 

## üß± Why We Use `SecurityFilterChain` (Spring Security 6+)

Spring Security 6 removed `WebSecurityConfigurerAdapter`.

The correct modern way is declaring `SecurityFilterChain` as a bean:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception
```

This gives full control over the filter pipeline.

---

## üîê AuthenticationManager Bean

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;

@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
    throws Exception {
    return config.getAuthenticationManager();
}
```

This exposes Spring's internal `Authentication Manager` so that:
- `AuthService` can authenticate a user during login
- it can validate username + password using `UserDetailsService` and password encoder

Without this bean, login would not work.

--- 

## üîÑ Summary Diagram

```
Client ‚Üí /api/auth/login ‚Üí (public)
    ‚Üí AuthService ‚Üí JWT created ‚Üí returned to client

Client ‚Üí /api/chat/messages ‚Üí 
    ‚Üí must include Authorization header
    ‚Üí SecurityFilterChain checks JWT
    ‚Üí if valid ‚Üí controller runs
    ‚Üí if invalid ‚Üí 401 Unauthorized
```

---

## üéØ Summary

| Feature                               | Explanation                                             |
|---------------------------------------|:--------------------------------------------------------|
| **CSRF disabled**                     | Not needed for stateless JWT APIs                       |
| **Public auth endpoints**             | `register` and `login` accessible without token         |
| **All other endpoints protected**     | Require valid JWT                                       |
| **AuthenticationManager exposed**     | Used for login password verification                    |
| **Modern Spring Security 6 approach** | Uses SecurityFilterChain instead of deprecated adapters |

This configuration forms the foundation of the **JWT-based security layer.**

---