# User Entity - Domain Design Decisions

This document explains the design decisions behind the `User` domain entity.

The goal of this entity is to model a **real-world chat application user** in a way that is:
- flexible
- secure
- future-proof
- easy to evolve

## üéØ Responsibilities of the User Entity

The `User` entity represents:
- an authenticated system user
- an identity used in conversations
- a participant in private and group chats

It is intentionally **focused on identity and authentication**, not on messaging logic.

---

## üÜî Identifier Strategy (UUID)

```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import org.hibernate.annotations.UuidGenerator;

@Id
@GeneratedValue
@UuidGenerator
private UUID id;
```

### Why UUID instead of Long
- safer in distributed systems
- harder to guess (security)
- avoids exposing internal database structure
- common choice in modern chat systems

---

## üìß Email

```java
import jakarta.persistence.Column;

@Column(nullable = false, unique = true, length = 255)
private String email;
```

### Design notes:
- email is used as the **primary login identifier**
- length(255) follows RFC recommendations
- must be globally unique

---

## üîê Password

```java
import jakarta.persistence.Column;

@Column(nullable = false)
private String password;
```

### Important:
- this field **never stores a plain password**
- only a hashed value (e.g. BCrypt)
- hashing is handled outside the entity (service layer)

---

## üë§ Display Identity (Name & Username)

```java
import jakarta.persistence.Column;

@Column(length = 30)
private String firstName;

@Column(length = 50)
private String lastName;

@Column(unique = true, length = 30)
private String username;
```

### Why this  combination?
The system supports **multiple ways to identify a user visually**:
1. `username` - preferred if present
2. `firstName + lastName` - fallback
3. generated identifier - last resort

This allows:
- simple onboarding (name only)
- social-style identifiers (username)
- future customization

---

## Display Name Logic

```java
public String getDisplayName() { ... }
```

The logic for determining how a user is displayed is **encapsulated inside the entity**.

This avoids:
- duplicated logic in controllers/services
- inconsistencies across the application

---

## üé≠ Role

```java
import com.chatapp.chat.user.UserRole;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;

@Enumerated(EnumType.STRING)
private UserRole role;
```

### Why enum?
- type safety
- readable database values
- easy extension (ADMIN, MODERATOR, etc.)

---

## ‚è± Auditing Fields
```java
private Instant createdAt;
private Instant updatedAt;
```

Managed automatically using JPA lifecycle* hooks.

### Why Instant?
- timezone-safe
- database-agnostic
- recommended for backend systems

---

## *üìå What are JPA lifecycle hooks?

JPA lifecycle hooks are special callback methods that JPA automatically executes at specific moments in the entity's 
life cycle.
They allow the entity to react to events such as being **created, updated, loaded** or **deleted.**

In this entity we use two hooks:

`@PrePersist`

Triggered right before the entity is inserted into the database.
We use it to initialize audit fields:

```java
import jakarta.persistence.PrePersist;

@PrePersist
public void onCreate() {
    this.createdAt = Instant.now();
    this.updatedAt = this.createdAt;
}
```

This ensures that both timestamps are set correctly when the user is created.

`@PreUpdate`

Triggered right before an existing entity is updated.
IT automatically updates the `updatedAt` timestamp:

```java
import jakarta.persistence.PreUpdate;

@PreUpdate
public void onUpdate() {
    this.updatedAt = Instant.now();
}
```

### Why this matters
- keeps audit fields accurate without manual intervention
- prevents forgotten timestamp updates
- centralizes lifecycle logic inside the entity
- keeps services and controllers cleaner

Using lifecycle hooks is a common practice in domain models that track creation and modification times.

---

## üö¶ Enabled Flag

```java
import jakarta.persistence.Column;

@Column(nullable = false)
private boolean enabled = true;
```

Allows:
- soft disabling accounts
- moderation
- future account lifecycle control

---

## üß© Summary
The `User` entity is designed to:
- model real chat application users
- support authentication and display need
- remain flexible for future features

It intentionally avoids:
- business logic
- chat/message relationships (handled elsewhere)
