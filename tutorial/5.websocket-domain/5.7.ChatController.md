# 5.7. ChatController

`ChatController` is a WebSocket/STOMP controller responsible for handling real-time chat communication. It receives 
messages from WebSocket clients and broadcasts them to all subscribers via `SimpMessagingTemplate`.

This class forms the core of the chat system's real-time behavior.

```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class ChatController {

    private final SimpMessagingTemplate messagingTemplate;
    private final MessageService messageService;

    @MessageMapping("/chat.sendMessage")
    public void sendMessage(@Payload ChatMessage message) {
        log.debug("Received WS message: {}", message);

        Message saved = messageService.save(
                Message.builder()
                        .chatId(message.getChatId())
                        .sender(message.getSender())
                        .content(message.getContent())
                        .build()
        );

        messagingTemplate.convertAndSend(
                "/topic/chat." + saved.getChatId(),
                message
        );
    }

    @MessageMapping("/chat.addUser")
    public void addUser(@Payload ChatMessage chatMessage) {
        chatMessage.setType(ChatMessageType.JOIN);

        messagingTemplate.convertAndSend(
                "/topic/chat." + chatMessage.getChatId(),
                chatMessage
        );
    }
}
```

--- 

## ðŸ“Œ Role of This Controller

`ChatController` handles **WebSocket (STOMP) events**, not REST HTTP requests.<br>
It operates within the prefix configured in `WebSocketConfig`:
- Client â†’ Server: `/app/**`
- Server â†’ Client: `/topic/**`

This controller is triggered when clients send messages to `/app/chat.*`

---

## ðŸ“Œ Methods Overview

### 1. `sendMessage(ChatMessage message)`

### Mapping

```java
@MessageMapping("/chat.sendMessage")
```

### Purpose:
Handles chat messages sent by users over WebSocket (e.g., text messages).

### Flow:
1. The client sends a `ChatMessage` to `/app/chat.sendMessage`.
2. Controller logs the incoming message.
3. It transforms the DTO into a `Message` entity.
4. It persists the message using `MessageService.save(...)`.
5. It broadcasts the original DTO to all subscribers at:

```powershell
/topic/chat.{chatId}
```

### Why save before sending?

Persistence ensures:
- message history is available for REST endpoints,
- chat state is fully synchronized across devices,
- reconnecting users can retrieve older messages.

### Why broadcast the original DTO instead of the DB entity?

STOMP messages represent what the client sent, not DB state.<br>
Clients do not need internal fields like UUID or timestamps (unless required later).

---

### 2. `addUser(ChatMessage chatMessage`

### Mapping:

```java
@MessageMapping("/chat.addUser")
```

### Purpose:
Handles new user joining a chat room.

### Flow:
1. Incoming message is converted to type `JOIN`
2. The message is broadcast to:
```java
/topic/chat.{chatId}
```
3. Other clients can update UI (e.g., show "User joined the chat").

### Why not persist JOIN events?

JOIN/LEAVE are *real-time events*, not stored chat messages.<br>
Persisting them would pollute message history.

---

## ðŸ“¡ Broadcasting Logic (SimpMessagingTemplate)
`messagingTemplate.convertAndSend(...)` sends a WebSocket message to every client subscribed to a topic.

Example:
```java
messagingTemplate.convertAndSend("/topic/chat.123", message);
```

All clients subscribed via:

```java
stompClient.subscribe("/topic/chat.123", callback);
```

will immediately receive the message.

---

## ðŸ“Œ Key Architectural Concepts

### âœ” Event-Driven Communication
This controller implements **publish-subscribe messaging** using STOMP.

### âœ” Separation of Concerns
- WebSocket concerns â†’ ChatController
- Persistence â†’ MessageService
- Entity mapping â†’ Message and MessageResponse
- Real-time delivery â†’ SimpMessagingTemplate

### âœ” Stateless Controller

WebSocket state (user identity, session, subscriptions) is handled at:
- Stomp session level
- Security context
- Client-side subscription logic

The controller itself remains stateless and threadsafe.

---

## ðŸ“Œ Future Improvements

### ðŸ”¹ 1. Deliver messages including metadata
Broadcast `MessageResponse` instead of raw DTO to include:
- message UUID
- timestamp
- sanitized/processed content

### ðŸ”¹ 2. Add typing indicators
`ChatMessageType.TYPING` could be added for UI enhancements.

### ðŸ”¹ 3. Add message editing / deleting
Extend controller with additional STOMP endpoints.

### ðŸ”¹ 4. Restrict broadcasts to authenticated users
Integrate with `JwtChannelInterceptor`, or Spring Security's WebSocket authentication.

---

## âœ” Summary
`ChatController` is the real-time backbone of the chat system:
- Receives messages from clients
- Persists them
- Broadcasts them to subscribers
- Handles JOIN events
- Uses STOMP & SimpMessagingTemplate for publish/subscribe messaging

This current MVP implementation is concise, scalable and production-ready for chat message flow.