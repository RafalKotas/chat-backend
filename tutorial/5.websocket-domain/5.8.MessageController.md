# 5.8 MessageController

### Overview

`MessageController` is the REST controller responsible for exposing **chat history over HTTP**.  
It is the counterpart to the WebSocket-based real-time communication handled by `WsChatController`.

Clients typically use this controller to:

- load historical messages after opening a chat,
- perform initial synchronization before subscribing to WebSocket updates.

---

## Class Definition

```java
@RestController
@RequestMapping("/api/messages")
@RequiredArgsConstructor
public class MessageController {

    private final MessageService messageService;

    @GetMapping("/{chatId}")
    public List<MessageResponse> getChatHistory(@PathVariable String chatId) {
        return messageService.getChatHistory(chatId)
                .stream()
                .map(MessageResponse::fromEntity)
                .toList();
    }
}
```

---

## Responsibilities

### 1. Provide a REST API for chat history retrieval

The controller exposes a single read-only endpoint:

```
GET /api/messages/{chatId}
```

It returns all messages belonging to the chat, **sorted chronologically**, based on the `createdAt` timestamp.


--- 

### 2. Convert database entities into safe REST DTOs

The controller **never returns JPA entities directly**.

Instead, each `Message` entity is converted to a REST-safe DTO using:

```java
MessageResponse.fromEntity(message)
```

Benefits:

- prevents exposing internal JPA/Hibernate structures
- avoids serialization of lazy-loaded relations
- ensures consistent REST payload format
- allows future changes to the DB layer without affecting API consumers

---

### 3. Delegate business logic to MessageService

All business logic is contained in the service layer.

```java
messageService.getChatHistory(chatId)
```

The controller itself only:
- receives input,
- delegates to the service,
- maps results to DTOs,
- returns the response.

This ensures **thin controllers** and follows Clean Architecture / DDD patterns.

---

## Endpoint Description

### GET `/api/messages/{chatId}`

#### Path Variable

| Name        | Type    | Description                                                |
|:------------|:--------|------------------------------------------------------------|
| chatId      | String  | Chat identifier of the chat whose history is requested     |

#### Response Example

```json
[
  {
    "id": "8d1aac1d-21ae-4878-aa21-92e3c0309fcd",
    "chatId": "group123",
    "sender": "Alice",
    "content": "Hello!",
    "createdAt": "2026-01-30T19:22:05.123Z"
  }
]
```

Returned when:
- the chat exists,
- messages are present (or an empty list otherwise).

---

## Error Handling

Although the controller itself does not throw exceptions explicitly, errors may arise from deeper layers:

#### 1. Chat not found

### Possible future error sources:
- `ChatNotFoundException`
- `UserNotInChatException`
- invalid chat permissions

These would be handled by the global `GlobalExceptionHandler`.

Because `chatId` is currently a `String`, malformed IDs do not trigger validation errors unless explicitly 
implemented in `MessageService`.

#### 2. Invalid chatId format

Because `chatId` is a simple `String`, invalid UUID formatting does not cause parsing errors — it's 
treated as a standard string.
If stronger validation is needed, it should be added in `MessageService`.

---

## Security Considerations

Whether this endpoint requires authentication depends on `SecurityConfig`.

Common production improvements:
- require a valid JWT
- verify user membership in the chat before returning history
- paginate responses (limit messages per page)

These features can be added later without modifying the controller itself.

---

## Integration With WebSocket Messaging

This REST endpoint is a complement to WebSocket messaging:

| Responsibility         | REST (MessageController) | WebSocket (`WsChatController`) |
|:-----------------------|:-------------------------|--------------------------------|
| Load history           | ✔ YES                    | ✖ NO                           |
| Receive real-time msgs | ✖ NO                     | ✔ YES                          |
| Guaranteed ordering    | ✔ YES (DB)               | depends on network latency     |
| Offline sync           | ✔ YES                    | ✖ NO                           |

### Typical frontend flow:
1. Connect to the WebSocket backend
2. Subscribe to `/topic/chat.{chatId}`
3. Fetch history using `GET /api/messages/{chatId}`
4. Display past messages
5. Keep receiving new messages over WebSocket

---

## Summary

`MessageController` is the REST access point for message history. It:

- exposes a clean and simple HTTP API
- delegates all business logic to `MessageService`
- converts entities to DTOs (`MessageResponse`)
- complements WebSocket real-time messaging
- follows the principles of clean, layered architecture

This controller completes the persistence + REST portion of the chat system, while `WsChatController` handles the real-time aspects.
