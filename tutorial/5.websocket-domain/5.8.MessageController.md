# 5.8 MessageController

### Overview

`MessageController` is a REST controller responsible for exposing chat history over HTTP. It allows the client 
(typically the frontend application) to fetch **all messages for a given chat**, ordered chronologically.

This controller is used **outside WebSocket communication**, primarily for:
- loading historical messages after entering a chat,
- initial synchronization before receiving real-time WS updates.

---

## Class Definition

```java
@RestController
@RequestMapping("/api/messages")
@RequiredArgsConstructor
public class MessageController {

    private final MessageService messageService;

    @GetMapping("/{chatId}")
    public List<MessageResponse> getChatHistory(@PathVariable String chatId) {
        return messageService.getChatHistory(chatId)
                .stream()
                .map(MessageResponse::fromEntity)
                .toList();
    }
}
```

---

## Responsibilities

### 1. Expose an HTTP API for retrieving chat history

The controller exposes a single read-only endpoint:

```
GET /api/messages/{chatId}
```

This endpoint returns all messages belonging to the specified chat, sorted by their creation timestamp (`createdAt`).

--- 

### 2. Convert domain entities into safe DTO objects

The controller **never returns JPA entities directly**.

Instead, `MessageResponse.fromEntity(...)` is used to transform:
- internal database model (`Message`)
- into a **serialization-safe DTO** (`MessageResponse`)

This prevents:
- unwanted lazy loading,
- leaking internal fields (e.g. sender DB IDs)
- exposing persistence concerns at the API layer.

---

### 3. Delegate business logic to MessageService

The controller does not access the database directly.

It relies strictly on:

```java
messageService.getChatHistory(chatId)
```

`MessageService` encapsulates:
- communication with `MessageRepository`,
- ordering by timestamp,
- future logic for filtering, validating chat membership, or paging.

This keeps the controller thin and aligned with **Clean Architecture** principles.

---

## Endpoint Description

### GET `/api/messages/{chatId}`

#### Path Variable

| Name        | Type    | Description                                               |
|:------------|:--------|-----------------------------------------------------------|
| chatId      | String  | Chat identifier (UUID or string-based)                    |

#### Response

`200 OK`

```json
[
  {
    "id": "8d1aac1d-21ae-4878-aa21-92e3c0309fcd",
    "chatId": "group123",
    "sender": "Alice",
    "content": "Hello!",
    "createdAt": "2026-01-30T19:22:05.123Z"
  }
]
```

#### When returned?
- When a chat with the given ID exists
- And messages have been created for that chat

---

## Error Handling

Although the controller itself does not throw exceptions explicitly, errors may arise from deeper layers:

#### 1. Chat not found

If in future service validates chat membership, `MessageService` may throw domain exceptions such as:
- `ChatNotFoundException`
- `UserNotInChatException`

These would be handled by the global `GlobalExceptionHandler`.

#### 2. Invalid chatId format

Because `chatId` is a simple `String`, invalid UUID formatting does not cause parsing errors — it's 
treated as a standard string.
If stronger validation is needed, it should be added in `MessageService`.

---

## Security Considerations

Currently, this endpoint does **not require authentication**, unless configured globally in `SecurityConfig`.

Typical production systems add:
- user authentication (JWT)
- membership validation (only chat participants can load messages)
- pagination<br>
  (to avoid sending thousands of messages)

These features can be implemented later in `MessageService`.

---

## Integration With WebSocket Messaging

This REST endpoint is a complement to WebSocket messaging:

| Responsibility         | REST (MessageController) | WebSocket         |
|:-----------------------|:-------------------------|-------------------|
| Load history           | ✔ yes                    | ✖ no              |
| Receive real-time msgs | ✖ no                     | ✔ yes             |
| Guaranteed ordering    | ✔ yes (DB)               | depends on client |
| Offline sync           | ✔ yes                    | ✖                 |

The typical client flow:
1. Connect to WebSocket
2. Subscribe to `/topic/chat.{chatId}`
3. Call `GET /api/messages/{chatId}` to load history
4. Receive new messages in real-time through WS

---

## Summary
`MessageController` is a simple but essential component that:
- provides REST access to message history
- delegates business logic to `MessageService`,
- returns safe DTOs,
- works alongside WebSocket messaging to create a full chat experience.

It keeps the API clean, stable, and easy to consume from the frontend while remaining extension-friendly for future 
features such as authentication, permissions, pagination, and message edits.
