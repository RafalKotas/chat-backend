# 5.7. MessageService

`MessageService` is the business-logic layer responsible for handling chat message operations. It acts as an 
intermediary between controllers (REST or WebSocket) and the persistence layer (`MessageRepository`).

```java
@Service
@RequiredArgsConstructor
public class MessageService {

    private final MessageRepository messageRepository;

    public Message save(Message message) {
        return messageRepository.save(message);
    }

    public List<Message> getChatHistory(String chatId) {
        return messageRepository.findAllByChatIdOrderByCreatedAtAsc(chatId);
    }
}
```

## ðŸ“Œ Responsibilities

### âœ” 1. Persisting New Messages

The `save(Message message)` method stores a new chat message in the database. It is used both by:
- the WebSocket `ChatController` when broadcasting incoming messages
- any future endpoints that may create messages asynchronously

This encapsulates all message-creation logic and isolates controllers from repository calls.

---

### âœ” 2. Retrieving Chat History
`getChatHistory(String chatId)` returns a list of messages belonging to a chat ordered by timestamp.

This method:
- provides the data for the REST endpoint `/api/messages/{chatId}`
- guarantees ordering by `createdAt ASC`
- abstracts away persistence details from controllers

---

## ðŸ“Œ Why This Service Layer Exists

Even though the current implementation is thin and delegates directly to the repository, it provides important 
architectural benefits:

### âœ” a place for future business rules

Examples of responsibilities that may be added soon:
- filtering banned or deleted messages
- applying message transformations (markdown â†’ HTML, sanitization, emojis)
- enriching message payloads (e.g., sender profile display name)
- enforcing rate limits
- validating a service prevents logic from leaking into controllers.

---

### âœ” decoupling controllers from persistence

Controllers should not:
- depend on JPA
- know how queries are built
- handle sorting, filtering, or validation

`MessageService` ensures a clean separation of concerns.

---

### âœ” improved testability
Unit tests target this service instead of tying into JPA infrastructure.<br>
This keeps tests fast, focused, and easier to mock in higher-level components.

---

## ðŸ“Œ Future Extensions
`MessageService` may expand to support:
### ðŸ”¹ Pagination
```java
Page<Message> getChatHistory(String chatId, Pageable page);
```
### ðŸ”¹ Moderation / Content Filters
Profanity filter, forbidden words detection, toxic message tagging, etc.
### ðŸ”¹ Permissions & Security
Ensuring a user belongs to a chat before accessing messages.
### ðŸ”¹ Message Deletion / Editing
Soft-delete or edit history support.
### ðŸ”¹ Event Publishing
Fire domain events when a new message is saved (analytics, notifications, etc.).

The current MVP-level service is intentionally simple but scalable for future needs.

---

## ðŸ“¤ Usage Example

Inside `ChatController`:

```java
Message saved = messageService.save(
    Message.builder()
        .chatId(message.getChatId())
        .sender(message.getSender())
        .content(message.getContent())
        .build()
);
```

Inside `MessageController`:

```java
return messageService.getChatHistory(chatId)
        .stream()
        .map(MessageResponse::fromEntity)
        .toList();
```

---

## âœ” Summary

`MessageService` is the core abstraction for message operations in the application.

It provides:
- clean separation from repository logic
- easy testability
- future-proof design for validation, business rules, and message processing
- a simple API (`save` and `getChatHistory`) used by both WebSocket and REST controllers

It is intentionally minimal in the MVP stage and ready for incremental feature growth.