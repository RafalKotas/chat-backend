# 5.9 JwtChannelInterceptor

### Overwiev

`JwtChannelInterceptor` is a custom **WebSocket STOMP inbound interceptor** responsible for authenticating users **during the STOMP CONNECT frame**.  

It mirrors the authentication logic used in HTTP requests but applies it to WebSocket connections.

Because browsers cannot send HTTP headers in a STOMP CONNECT frame, the token must be passed as a **native STOMP 
header:**

```
Authorization: Bearer <jwt>
```

---

## Class Definition

```java
@Slf4j
@RequiredArgsConstructor
public class JwtChannelInterceptor implements ChannelInterceptor {

    private final JwtUtils jwtUtils;

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);

        if (!StompCommand.CONNECT.equals(accessor.getCommand())) {
            return message;
        }

        String token = accessor.getFirstNativeHeader("Authorization");

        if (token == null || !token.startsWith("Bearer ")) {
            log.debug("Missing or invalid auth header in WS CONNECT");
            return message;
        }

        token = token.substring(7);

        if (!jwtUtils.isValid(token)) {
            log.debug("Invalid JWT token in WS CONNECT");
            return null;
        }

        String username = jwtUtils.extractUserName(token);

        UsernamePasswordAuthenticationToken auth =
                new UsernamePasswordAuthenticationToken(username, null, null);

        log.debug("Websocket user authenticated");

        SecurityContextHolder.getContext().setAuthentication(auth);
        accessor.setUser(auth);

        return org.springframework.messaging.support.MessageBuilder
                .createMessage(message.getPayload(), accessor.getMessageHeaders());
    }
}
```

---

## Responsibilities

### ✔ 1. Intercept only STOMP CONNECT frames
The interceptor checks:

```java
if (!StompCommand.CONNECT.equals(accessor.getCommand()))
```

All other STOMP commands (`SEND`, `SUBSCRIBE`, `DISCONNECT`, etc.) are ignored.

Benefits:
- authentication is done **once** at the start of the connection,
- minimal overhead during regular chat messaging.

---

### ✔ 2. Extract JWT from native STOMP headers

Since WebSockets do not support HTTP headers, the JWT must be passed in STOMP’s native headers.

```java
String token = accessor.getFirstNativeHeader("Authorization");
```

Format must match REST conventions:

```
Authorization: Bearer <token>
```

---

### Validate the JWT token

If token is missing, malformed, or fails verification:
- A debug log is printed
- For malformed token → connection is allowed (message returned unchanged)
- For invalid token → connection is rejected (`return null`)

Why these two behaviors differ?

| Case                             | Behavior         | Reason                                   |
|:---------------------------------|:-----------------|------------------------------------------|
| Missing/Bad header format        | `return message` | Client might retry or fix header         |
| Invalid signature/expired token  | `return null`    | Immediately reject attack/invalid token  |

--- 

### ✔ 4. Authenticate the WebSocket session

If the token is valid:

```java
UsernamePasswordAuthenticationToken auth =
    new UsernamePasswordAuthenticationToken(username, null, null);
```

The authentication object is stored in:
- `SecurityContextHolder`
- STOMP session (`accessor.setUser(auth)`)

This allows:
- accessing authenticated user info in WebSocket controllers,
- sending user-specific messages,
- permission checks for chat rooms.

---

### ✔ 5. Return a new immutable STOMP message

STOMP message headers are immutable, so Spring requires building a fresh message:

```java
return MessageBuilder.createMessage(
    message.getPayload(),
    accessor.getMessageHeaders()
);
```

Failing to do so can cause the modified headers to be ignored by the broker.

---

## Security Implications

### Why do we need WebSocket authentication?

WebSocket connections bypass standard HTTP filters.

Without this interceptor:
- any anonymous user could connect via `/ws`,
- subscribe to `/topic/*`,
- impersonate another user,
- send messages fraudulently.

This would break all chat security guarantees.

`JwtChannelInterceptor` restores security parity between HTTP and WS layers.

---

### JWT over WebSocket — is it safe?

Yes, because:
- JWT is validated the same way as REST,
- token never leaves the server once received,
- STOMP headers are not exposed to other clients.

Recommendation:
- always use `wss://` in production.

---

## Enabling the Interceptor

Currently the interceptor exists but is **not registered**.

To activate it, modify `WebSocketConfig`:

```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new JwtChannelInterceptor(jwtUtils));
}
```

## Client Flow Example

1. User logs in via REST → receives JWT
2. Client opens WebSocket connection:

```
stompClient.connect(
  { Authorization: "Bearer " + token },
  onConnected,
  onError
);
```

3. Interceptor validates the token
4. Authenticated Principal is attached to the session
5. User receives/sends messages only to allowed chat rooms

---

## Summary

`JwtChannelInterceptor` adds essential authentication support to the WebSocket communication layer.

It:
- verifies JWT tokens during CONNECT,
- rejects invalid connections,
- attaches authenticated user info to the session,
- integrates WebSocket security with the main Spring Security context.

It is crucial for protecting chat channels and enabling user-specific real-time features.
