# 5.10 JwtChannelInterceptor

### Overwiev

`JwtChannelInterceptior` is a custom **WebSocket STOMP interceptor** responsible for authenticating users **during the 
WebSocket CONNECT frame**.

This interceptor mirrors HTTP authentication logic from the REST layer but applies it specifically to WebSocket 
connections.

Because browsers cannot send HTTP headers in a STOMP CONNECT frame, the token must be passed as a **native STOMP 
header:**

```
Authorization: Bearer <jwt>
```

---

## Class Definition

```java
@Slf4j
@RequiredArgsConstructor
public class JwtChannelInterceptor implements ChannelInterceptor {

    private final JwtUtils jwtUtils;

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);

        if (!StompCommand.CONNECT.equals(accessor.getCommand())) {
            return message;
        }

        String token = accessor.getFirstNativeHeader("Authorization");

        if (token == null || !token.startsWith("Bearer ")) {
            log.debug("Missing or invalid auth header in WS CONNECT");
            return message;
        }

        token = token.substring(7);

        if (!jwtUtils.isValid(token)) {
            log.debug("Invalid JWT token in WS CONNECT");
            return null;
        }

        String username = jwtUtils.extractUserName(token);

        UsernamePasswordAuthenticationToken auth =
                new UsernamePasswordAuthenticationToken(username, null, null);

        log.debug("Websocket user authenticated");

        SecurityContextHolder.getContext().setAuthentication(auth);
        accessor.setUser(auth);

        return org.springframework.messaging.support.MessageBuilder
                .createMessage(message.getPayload(), accessor.getMessageHeaders());
    }
}
```

---

## Responsibilities

### Intercept STOMP CONNECT framse

The interceptor looks only at:

```
STOMP CONNECT
```

frames.

It ignores all other message types (`SEND`, `SUBSCRIBE`, `DISCONNECT`, ...).

This ensures:
- minimal performance impact
- authentication is performed only once, at connection time

---

### 2. Extract JWT token from STOMP headers

WebSocket STOMP frames do not support traditional HTTP headers, so JWT is passed through *native headers.*

The interceptor fetches it with:

```java
accessor.getFirstNativeHeader("Authorization");
```

Expected format is identical to REST API:

```
Bearer <jwt-token>
```

---

### Validate the JWT token

If token is missing, malformed, or fails verification:
- A debug log is printed
- For malformed token → connection is allowed (message returned unchanged)
- For invalid token → connection is rejected (`return null`)

Why these two behaviors differ?

| Case                             | Behavior         | Reason                                   |
|:---------------------------------|:-----------------|------------------------------------------|
| Missing/Bad header format        | `return message` | Client might retry or fix header         |
| Invalid signature/expired token  | `return null`    | Immediately reject attack/invalid token  |

--- 

### 4. Build WebSocket Authentication object

When the JWT is valid:

```java
UsernamePasswordAuthenticationToken auth =
        new UsernamePasswordAuthenticationToken(username, null, null);
```

This object integrates with Spring Security the same way as in HTTP requests.

The authentication is then injected into:
- `SecurityContextHolder`
- STOMP session (`accessor.setUser(auth)`)

This allows:
- future message handlers to obtain `Principal`
- user-based message routing
- private chat rooms

---

### 5. Return a fresh immutable Message

Because STOMP messages are immutable, Spring recommends creating a **new message instance** when modifying headers:

```java
return MessageBuilder.createMessage(
    message.getPayload(),
    accessor.getMessageHeaders()
);
```

If we returned the original message, Spring might ignore updated headers in certain broker implementations.

---

## Security Implications

### Why do we need WebSocket authentication?

WebSocket connections bypass standard HTTP filters.

Without this interceptor:
- any unauthenticated client cloud open a WebSocket session,
- send messages,
- subscribe to other users' topics,
- impersonate users,
- or intercept private messages.

`JwtChannelInterceptor` restores security parity between HTTP and WS layers.

---

### Why JWT is safe for WebSockets?

Because STOMP frames are routed only inside the application, and JWT validation still happens server-side. 

However:
- WebSockets do not automatically renew tokens,
- Token expiration must be handled manually (optional future feature),
- Secure WebSocket URL (`wss://`) is highly recommended.

---

## Integration in WebSocketConfig

Currently, the interceptor is prepared but not yet registered.

To enable it, add:
```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new JwtChannelInterceptor(jwtUtils));
}
```

This would activate full WebSocket authentication.

---

## Typical Client Flow
1. User logs in via REST → receives JWT
2. Client opens WebSocket:

```
stompClient.connect(
  { Authorization: "Bearer " + token },
  onConnected,
  onError
);
```
3. Server intercepts the CONNECT frame
4. Token is validated
5. `Principal` is attached to the WebSocket session
6. User can join chats and send messages securely

---

## Summary

`JwtChannelInterceptor` adds essential authentication support to the WebSocket communication layer.

It:
- verifies JWT tokens during CONNECT,
- rejects invalid connections,
- attaches authenticated user info to the session,
- integrates WebSocket security with the main Spring Security context.

This interceptor is a critical building block for secure real-time messaging.
