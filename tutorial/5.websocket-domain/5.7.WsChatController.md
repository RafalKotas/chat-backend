# 5.7. WsChatController

`WsChatController` is the WebSocket/STOMP controller responsible for handling **real-time chat communication**. It 
receives incoming STOMP frames from clients (`WsInboundMessage`) and broadcasts standardized `WsOutboundMessage` 
objects to all subscribers using `SimpMessagingTemplate`.

It forms the backbone of the systemâ€™s *real-time messaging layer*.

```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class WsChatController {

    private final SimpMessagingTemplate messagingTemplate;
    private final MessageService messageService;

    @MessageMapping("/chat.sendMessage")
    public void sendMessage(@Payload ChatMessage message) {
        log.debug("Received WS message: {}", message);

        Message saved = messageService.save(
                Message.builder()
                        .chatId(message.getChatId())
                        .sender(message.getSender())
                        .content(message.getContent())
                        .build()
        );

        messagingTemplate.convertAndSend(
                "/topic/chat." + saved.getChatId(),
                message
        );
    }

    @MessageMapping("/chat.addUser")
    public void addUser(@Payload ChatMessage chatMessage) {
        chatMessage.setType(ChatMessageType.JOIN);

        messagingTemplate.convertAndSend(
                "/topic/chat." + chatMessage.getChatId(),
                chatMessage
        );
    }
}
```

--- 

## ğŸ“Œ Role of This Controller

`WsChatController` works entirely in the **WebSocket domain**, not HTTP.  
The routing is defined by `/app/**` prefixes configured in `WebSocketConfig`.
- Clients **send** messages to:  
  `/app/chat.*`
- Backend **broadcasts** to:  
  `/topic/chat.{chatId}`

It implements two real-time behaviors:
- sending chat messages
- notifying when users join chats

---

## ğŸ“Œ WebSocket Endpoints

## 1ï¸âƒ£ `@MessageMapping("/chat.sendMessage")`

### **Purpose**
Handles **chat messages sent by users** over WebSocket.

### **Flow**
1. Client sends a `WsInboundMessage` to `/app/chat.sendMessage`
2. Controller converts inbound DTO â†’ JPA `Message`
3. Message is persisted using `MessageService.save(...)`
4. A `WsOutboundMessage` is created from the saved entity
5. Broadcast to:  
   `/topic/chat.{chatId}`

### **Why convert inbound â†’ DB entity â†’ outbound?**

- inbound: temporary client payload
- entity: stored long-term
- outbound: enriched data sent to all subscribers  
  (includes UUID + timestamp)

This decoupling keeps the protocol clean and prevents exposing internal persistence fields directly.

---

## 2ï¸âƒ£ `@MessageMapping("/chat.addUser")`

### **Purpose**
Broadcasts an event when a user joins a chat.

### **Flow**
1. Client sends minimal inbound message (`chatId`+`sender`)
2. Controller creates `WsOutboundMessage` of type `JOIN`
3. Event is broadcast to subscribers

### **Why JOIN is not persisted?**
JOIN/LEAVE are ephemeral presence events that should not appear in chat history.

---

## ğŸ“¡ Broadcasting Logic

The controller sends outbound messages using:

```java
messagingTemplate.convertAndSend("/topic/chat." + chatId, payload);
```

All clients subscribed to the topic receive the update instantly.

This implements the **publish/subscribe** pattern.

---

## ğŸ“Œ Key Architectural Concepts

### âœ” Inbound vs Outbound Model
- `WsInboundMessage` â€“ what clients send
- `WsOutboundMessage` â€“ standardized, enriched form sent back to clients  
  (includes DB metadata: id, createdAt)

### âœ” Persistence Delegation
`WsChatController` does not touch the DB directly â€” it delegates to `MessageService`.

### âœ” Statelessness
No server state is stored inside the controller.  
Each WebSocket frame is processed independently.

---

## ğŸ“Œ Future Improvements

### ğŸ”¹ Typing indicators
Add new message types like `TYPING_START` and `TYPING_STOP`.

### ğŸ”¹ Message editing & deletion
STOMP endpoints for:
- `/chat.editMessage`
- `/chat.deleteMessage`

### ğŸ”¹ WebSocket authentication
Integrate deeply with `JwtChannelInterceptor`.

### ğŸ”¹ Delivery receipts
Extend outbound messages with metadata:
- `readBy: []`
- `deliveredAt`

---

## âœ” Summary

`WsChatController` orchestrates WebSocket communication by:

- receiving inbound messages from clients
- persisting chat messages
- constructing outbound message payloads
- broadcasting real-time events (CHAT, JOIN)
- ensuring a clean separation between transport and persistence layers

It is lightweight, scalable, and perfectly suited for the MVP version of your chat system.
