# 5.11 STOMP Client Flow (How WebSocket Clients Communicate with the Server)

### Overview

This document describes **how a frontend clients connect, authenticate, subscribe, and exchange real-time messages** 
with the backend using STOMP over WebSocket.

The flow described here corresponds directly with:
- `WebSocketConfig`
- `WsChatController`
- `WsInbound` / `WsOutboundMessage`
- REST history loading via `MessageController`
- (optionally) `JwtChannelInterceptor`

---

## 1. WebSocket Endpoint

The backend exposes a single WebSocket handshake endpoint:

```
/ws
```

The client must connect using a STOMP library (`stompjs`, `@stomp/stompjs`, SockJS, etc.).

Client-side JavaScript example:

```
import { Client } from "@stomp/stompjs";

const socket = new WebSocket("ws://localhost:8080/ws");

const stompClient = new Client({
  webSocketFactory: () => socket,
});
```

After connecting, all communication uses **STOMP frames**, not raw WebSocket messages.

---

## 2. STOMP Connection With JWT

If JWT WebSocket authentication is enabled (via `JwtChannelInterceptor`), the client must attach a header:

```
Authorization: Bearer <token>
```

STOMP headers example:

```
stompClient.activate();

stompClient.onConnect = () => { ... };

stompClient.connectHeaders = {
  Authorization: "Bearer " + token
};
```

This header will be consumed by the backend during `STOMP CONNECT`.

---

## 3. Subscribing to a Chat Topic

After connecting, the client must subscribe to a specific chat room:

```
stompClient.subscribe(
  `/topic/chat.${chatId}`,
  (frame) => {
    const msg = JSON.parse(frame.body);
    console.log("Incoming WS message:", msg);
  }
);
```

### All server messages targeting this room are published to:

```
/topic/chat.{chatId}
```

via `WsChatController`.

---

## 4. Sending Messages to a Chat

Messages are sent to methods annotated with `@MessageMapping`.

Backend mapping:

```java
@MessageMapping("/chat.sendMessage")
```

→ Client sends to:

```
/app/chat.sendMessage
```

Example:

```
stompClient.send(
  "/app/chat.sendMessage",
  {},
  JSON.stringify({
    chatId: "room-1",
    sender: "Alice",
    content: "Hello world",
    type: "CHAT"
  })
);
```

Backend flow inside `WsChatController`:

1. Receives `WsInboundMessage`
2. Saves it as **Message** JPA entity
3. Creates `WsOutboundMessage`
4. Broadcasts it to `/topic/chat.room-1`

All subscribed clients receive `WsOutboundMessage`.

---

## 5. Joining a Chat Room

`ChatController` provides a second mapping:

```java
@MessageMapping("/chat.addUser")
```

Client must notify the server when a user joins the room:

```
stompClient.send(
  "/app/chat.addUser",
  {},
  JSON.stringify({
    chatId: "room-1",
    sender: "Alice",
    type: "JOIN"
  })
);
```

The backend automatically overrides:

```
type = JOIN
```

and broadcasts the event - `WsOutboundMessage` to all listeners.

---

## 6. WebSocket Message Lifecycle

### 1. Client → Server

| Action            | STOMP Destination       | Payload (DTO)      |
|:------------------|:------------------------|--------------------|
| Send chat message | `/app/chat.sendMessage` | `WsInboundMessage` |
| Notify join event | `/app/chat.addUser`     | `WsInboundMessage` |

---

### 2. Server-side processing
`WsChatController`:
- logs the message,
- persists chat messages (`CHAT`) using `MessageService`,
- transforms incoming DTO into `WsOutboundMessage`,
- broadcasts to:

```
/topic/chat.{chatId}
```

---

### 3. Server → Client (Broadcast)

All users subscribed to:

```
/topic/chat.room-1
```

receive:
- `CHAT` messages (with timestamps + IDs)
- `JOIN` events
- `LEAVE` events (future)

via `WsOutboundMessage`.

---

## 7. Example Full Communication Flow

### 1. Client opens WebSocket

```
GET ws://server:8080/ws
```

→ STOMP session established

### 2. Client subscribes

SUBSCRIBE destination:/topic/chat.room-1

### 3. Client joins

```
SEND /app/chat.addUser
{
    "chatId": "room-1",
    "sender": "Alice"
}     
```

Server broadcasts::

```json
{ type: "JOIN", sender: "Alice", chatId: "room-1" }
```

### 4. User sends a chat message

```
SEND /app/chat.sendMessage
{ "chatId": "room-1", 
  "sender": "Alice", 
  "content": "Hello" 
}
```

Server:
- persists message,
- wraps it into `WsOutboundMessage`,
- broadcasts to `/topic/chat.room-1`.

### 5. Other users receive

```
MESSAGE from /topic/chat.room-1
```

---

## 8. Integration With REST Chat History

WebSocket handles **new** messages only.

Clients must fetch history separately:

```
GET /api/messages/{chatId}
```

Before opening WebSocket, typical flow:

```
const history = await fetch("/api/messages/room-1");
const messages = await history.json();
```

---

## 9. Client Library Recommendations

#### JavaScript:
- `@stomp/stompjs` (recommended)
- `stompjs` + `sockjs-client` (fallback for older browsers)
#### Flutter:
- `stomp_dart_client`
#### Android/Kotlin:
- Raw WebSocket + custom STOMP implementation

---

## 10. Security Considerations
- JWT must be validated inside `JwtChannelInterceptor`
- WebSocket CORS should be restricted in production
- Messages should never be trusted without backend validation
- Only authenticated users should be allowed to subscribe

---

## Summary

The STOMP WebSocket client flow is:

```
Connect → Subscribe → Send → Receive
```

This mechanism enables:
- real-time messaging
- join / leave notifications
- message persistence
- secure and consistent communication
- full synchronization between REST history and live WS updates

STOMP + Spring WebSocket form a highly structured, scalable communication layer for chat applications.