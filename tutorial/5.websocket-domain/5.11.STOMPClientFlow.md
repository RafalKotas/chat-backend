# 5.11 STOMP Client Flow (How WebSocket Clients Communicate with the Server)

### Overview

This document describes **how a frontend client connects, authenticates, sends messages, and subscribes** to 
WebSocket/STOMP endpoints exposed by the backend.

It serves as a technical guide for frontend developers implementing real-time communication using STOMP (e.g., React, 
Angular, Vue, or plain JavaScript).

The flow described here corresponds directly with:
- `WebSocketConfig`
- `ChatController`
- `MessageController`
- (optionally) `JwtChannelInterceptor`

---

## 1. WebSocket Endpoint

The backend exposes a single WebSocket handshake endpoint:

```
/ws
```

The client must connect using a STOMP library (`stompjs`, `@stomp/stompjs`, SockJS, etc.).

Example JavaScript:

```
import { Client } from "@stomp/stompjs";

const socket = new WebSocket("ws://localhost:8080/ws");

const stompClient = new Client({
  webSocketFactory: () => socket,
});
```

---

## 2. STOMP Connection With JWT

If JWT authorization interceptor is enabled, clients must attach:

```
Authorization: Bearer <token>
```

STOMP headers example:

```
stompClient.connect(
  { Authorization: "Bearer " + token },
  onConnected,
  onError
);
```

---

## 3. Subscribing to a Chat Topic

After connecting, the client must subscribe to a specific chat room:

```
stompClient.subscribe(
  "/topic/chat." + chatId,
  (payload) => {
    const message = JSON.parse(payload.body);
    console.log("Received:", message);
  }
);
```

### Topics follow the format:

```
/topic/chat.{chatId}
```

All messages sent to this chat room will be broadcast to subscribers.

---

## 4. Sending Messages to a Chat

Messages are sent to methods annotated with `@MessageMapping`.

Backend mapping:

```java
@MessageMapping("/chat.sendMessage")
```

→ Client sends to:

```
/app/chat.sendMessage
```

Example:

```
stompClient.send(
  "/app/chat.sendMessage",
  {},
  JSON.stringify({
    chatId: "room-1",
    sender: "Alice",
    content: "Hello world",
    type: "CHAT"
  })
);
```

The server will:
1. Save the message to database via `MessageService`.
2. Broadcast it to:

```
/topic/chat.room-1
```

3. All connected clients receive the payload.

---

## 5. Joining a Chat Room

`ChatController` provides a second mapping:

```java
@MessageMapping("/chat.addUser")
```

Client must notify the server when a user joins the room:

```
stompClient.send(
  "/app/chat.addUser",
  {},
  JSON.stringify({
    chatId: "room-1",
    sender: "Alice",
    type: "JOIN"
  })
);
```

The backend automatically overrides:

```
type = JOIN
```

and broadcasts the event to all listeners.

---

## 6. Message Lifecycle

### 1. Client → Server

| Action            | Destination             | Example      |
|:------------------|:------------------------|--------------|
| Send chat message | `/app/chat.sendMessage` | JSON payload |
| Notify join event | `/app/chat.addUser`     | JSON payload |

---

### 2. Server-side processing
- `ChatController` receives STOMP payload.
- It creates a `Message` entity from the payload.
- The message is persisted in PostgreSQL.
- The server publishes the message via:

```
/topic/chat.{chatId}
```

---

### 3. Server → Client (Broadcast)

All users subscribed to:

```
/topic/chat.room-1
```

receive:
- chat messages,
- join notifications,
- (later) leave notifications.

---

## 7. Example Full Flow

### 1. User connects

```
GET ws://server:8080/ws
```

→ STOMP session established

### 2. User subscribes

SUBSCRIBE destination:/topic/chat.room-1

### 3.User joins

```
SEND /app/chat.addUser
{
    "chatId": "room-1",
    "sender": "Alice"
}     
```

→ Everyone receives `JOIN` event

### 4. User sends message

```
SEND /app/chat.sendMessage
{ "chatId": "room-1", 
  "sender": "Alice", 
  "content": "Hello" 
}
```

→ Stored in DB
→ Broadcast to `/topic/chat.room-1`

### 5. Other users receive

```
MESSAGE from /topic/chat.room-1
```

---

### 8. Integration With REST Chat History

WS only handles **live messages**.

To load historical messages, the client must call:

```
GET /api/messages/{chatId}
```

Response format in `MessageResponse`.

Example React code:

```
const history = await fetch("/api/messages/room-1");
const messages = await history.json();
```

---

### 9. Client Library Recommendations

#### JavaScript:
- `@stomp/stompjs` (recommended)
- `stompjs` + `sockjs-client` (fallback for older browsers)
#### Flutter:
- `stomp_dart_client`
#### Android/Kotlin:
- `okhttp` (raw WebSocket)
- community STOMP libs

---

### 10. Security Considerations
- WebSockets bypass normal Spring Security filters.
- JWT must be validated manually using `JwtChannelInterceptor`.
- CORS for `/ws` should be restricted in production.
- Clients must not trust any WS message without server validation.

---

## Summary

The STOMP WebSocket flow supports:
- real-time broadcast messaging,
- chat rooms,
- join/leave events,
- persistent storage of messages,
- optional JWT-based authentication.

Clients interact through a predicatable routing structure:

```
Connect → Subscribe → Send → Receive
```

This makes the communication layer scalable, structured, and easy to integrate with any frontend technology.