# 5.10 WebSocketConfig

### Overview

`WebSocketConfig` is the central configuration class responsible for enabling and setting up **WebSocket communication 
using STOMP** within the application.

It defines:
- the **WebSocket endpoint** (`/ws`),
- allowed CORS origins,
- server-side **STOMP broker configuration**,
- prefixes for application messages,

and establishes the messaging architecture used by the chat system.

This configuration is required for real-time communication via WebSockets and works together with `ChatController` 
and optional `JwtChannelInterceptor`.

---

## Class Definition

```java
package com.chatapp.chat.websocket;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOrigins("*");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
    }

}
```

---

## Responsibilities

### 1. Enable STOMP-based WebSocket Messaging

The class is annotated with:

```java
@EnableWebSocketMessageBroker
```

This activates:
- WebSocket message handling,
- STOMP protocol support,
- internal message routing through the broker.

Spring Boot automatically configures the required infrastructure.

---

### 2. Expose WebSocket Endpoint

```java
registry.addEndpoint("/ws")
        .setAllowedOrigins("*");
```

This creates the WebSocket handshake URL:

```
ws://<server>/ws
```

#### Allowed Origins

`setAllowedOrigins("*")` permits all domains during development.<br>
In production, this should be replaced with explicit origins for security, e.g.:

```java
.setAllowedOrigins("https://mydomain.com");
```

#### Why only `/ws`?

Clients connect once:

```javascript
stompClient.connect({}, onConnected, onError);
```

All messaging afterward uses STOMP frames routed internally.

---

### 3. Configure Message Broker

```java
registry.setApplicationDestinationPrefixes("/app");
```

This means:

Messages sent *from client to server* must begin with:

```
/app/...
```

Example client call:

```
stompClient.send("/app/chat.sendMessage", {}, JSON.stringihy(msg));
```

These messages are routed to methods annotated with:

```java
import org.springframework.messaging.handler.annotation.MessageMapping;

@MessageMapping(...)
```

---

### 4. Enable Simple In-Memory Broker

```java
registry.enableSimpleBroker("/topic");
```

This creates a built-int lightweight message broker that handles server → client messaging.

Messages sent to destinations like:

```
/topic/chat.{chatId}
```

This is ideal for:
- public chat rooms
- group messaging
- real-time notifications

For large-scale production deployments, the broker can be replaced with RabbitMQ or ActiveMQ.

---

## Message Routing Summary

| Direction       | Prefix   | Example                    | Routed To                 |
|:----------------|:---------|----------------------------|---------------------------|
| Client → Server | `/app`   | `/app/chat.sendMessage`    | `@MessageMapping` methods |
| Server → Client | `/topic` | `/topic/chat.123`          | Subscribed clients        |

---

## How It Works Together

### With ChatController

`ChatController` uses `@MessageMapping`:

```java
@MessageMapping("/chat.sendMessage")
```

Client send messages to:

```
/app/chat.sendMessage
```

Spring receives them → invokes the controller → broadcasts using:

```java
messagingTemplate.convertAndSend("/topic/chat." + chatId, msg)
```

---

### With JwtChannelInterceptor (optional)

Although currently not enabled, `WebSocketConfig` can integrate authorization:

```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new JwtChannelInterceptor(jwtUtils));
}
```

This would:
- authenticate WebSocket users,
- assign `Principal` to sessions,
- block connections with invalid tokens.

Recommended for secure chat rooms.

---

## Why STOMP?

Stomp provides:
- standardized messaging semantics,
- frame-based communication instead of raw WebSocket events,
- built-in routing,
- support for subscription channels,
- easy broadcast patterns (`/topic`),
- compatibility with many messaging brokers.

This is far superior to a manual "send raw JSON over WebSocket" approach.

---

## Security Considerations

### CORS

`setAllowedOrigins("*")` is convenient for development but not safe for production. <br>
Restricting origins is strongly recommended.

### Authentication

WebSockets bypass HTTP filters, so security requires an interceptor such as `JwtChannelInterceptor`.

### Broker Exposure

Only `/topic` is enabled, keeping routing predictable and limited

---

## Summary

`WebSocketConfig` is the foundational configuration for enabling real-time communication in the chat application. It:
- defines WebSocket/STOMP endpoints,
- configures routing prefixes,
- enables a built-in message broker,
- integrates with controller message handlers,
- optionally supports JWT authentication.

This class establishes the messaging infrastructure for all future chat features.

