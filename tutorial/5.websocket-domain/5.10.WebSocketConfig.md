# 5.10 WebSocketConfig

### Overview

`WebSocketConfig` is the central configuration class responsible for enabling and setting up 
**WebSocket communication using STOMP**.

It defines:
- the **WebSocket endpoint** (`/ws`),
- allowed CORS origins,
- STOMP message broker configuration,
- application destination prefixes,

and provides the messaging foundation used by the chat system together with:

- `WsChatController`
- `WsInboundMessage` / `WsOutboundMessage`
- (optional) `JwtChannelInterceptor`

---

## Class Definition

```java
package com.chatapp.chat.websocket;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOrigins("*");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
    }

}
```

---

## Responsibilities

### 1. Enable STOMP-based WebSocket Messaging

The class is annotated with:

```java
@EnableWebSocketMessageBroker
```

This activates:
- WebSocket message handling,
- STOMP protocol support,
- internal message routing through the broker.

This enables the application to use publish/subscribe messaging.

Spring Boot automatically configures the required infrastructure.

---

### 2. Expose the WebSocket handshake endpoint

```java
registry.addEndpoint("/ws").setAllowedOrigins("*");
```

This exposes:

```
ws://<server>/ws
```

Clients connect using this endpoint before sending STOMP frames.

#### Allowed Origins

`setAllowedOrigins("*")` permits all domains during development.<br>
In production, this should be replaced with explicit origins for security, e.g.:

```java
.setAllowedOrigins("https://mydomain.com");
```

#### Why only `/ws`?

Clients connect once:

```javascript
stompClient.connect({}, onConnected, onError);
```

All messaging afterward uses STOMP frames routed internally.

---

## ✔ 3. Configure Application Destinations

```java
registry.setApplicationDestinationPrefixes("/app");
```

Client → Server messages **must** begin with `/app`, for example:

```
/app/chat.sendMessage
```

These are routed to methods annotated with:

```java
@MessageMapping(...)
```

inside `WsChatController`.

---

## ✔ 4. Enable STOMP Broker for outgoing messages

```java
registry.enableSimpleBroker("/topic");
```

This sets up an in-memory broker used to broadcast:

```
/topic/chat.<chatId>
```

All clients subscribed to that topic will instantly receive the message.

The simple broker is sufficient for MVP and small deployments.

Later, you can replace it with:

- RabbitMQ
- ActiveMQ
- Kafka (via a custom bridge)

---

# Message Routing Summary

| Direction           | Prefix   | Example                   | Handled By                           |
|---------------------|----------|---------------------------|--------------------------------------|
| Client → Server     | `/app`   | `/app/chat.sendMessage`   | `@MessageMapping` (WsChatController) |
| Server → Client     | `/topic` | `/topic/chat.123`         | STOMP broker                         |

---

## Integration With WsChatController

Client sends:

```
stomp.send("/app/chat.sendMessage", {}, JSON.stringify(msg));
```

Server:

1. receives the message,
2. converts it to a domain entity (`Message`),
3. persists it via `MessageService`,
4. broadcasts `WsOutboundMessage` to:

```
/topic/chat.<chatId>
```

---

## Integration With JwtChannelInterceptor (optional)

Currently, **disabled**, but ready to be enabled.

To enforce authentication for WebSockets:

```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new JwtChannelInterceptor(jwtUtils));
}
```

This will:

- verify JWT during CONNECT,
- attach authenticated `Principal`,
- block unauthorized WebSocket access.

---

## Why STOMP Instead of Raw WebSockets?

STOMP provides:

- subscription channels (`/topic/...`)
- defined frame structure
- message routing
- separation of sending vs subscribing
- support for brokers
- scalable architecture

Raw WebSockets provide none of these features without custom code.

---

## Security Considerations

### CORS
`"*"` is acceptable only during development.

### Authentication
Required for:
- private chats,
- user presence,
- read receipts,
- message security.

To enable → use `JwtChannelInterceptor`.

### Broker Exposure
Only `/topic` is exposed, reducing attack surface.

---

## Summary

`WebSocketConfig` sets up the real-time backbone of the chat system:

- exposes `/ws` endpoint,
- enables STOMP,
- configures routing prefixes `/app` and `/topic`,
- enables lightweight message broker,
- integrates with `WsChatController`,
- supports optional JWT-based WebSocket authentication.

It provides a clean, predictable and scalable base for all WebSocket communication in the application.