# 6.6 ChatRepository

`ChatRepository` is the **primary data access layer** for managing chat rooms in the system.<br>
It provides JPQL-powered queries to:
- fetch all chats a user participates in,
- detect direct (1-to-1) chats between users,
- retrieve chat information efficiently through entity associations,=.

This repository work closely with:
- `ChatService`
- `ChatParticipantRepository`
- Entities `Chat` and `ChatParticipant`

Its queries are optimized for the architecture where **chat participants** are stored in a separate table.

---

## ✔ Repository Definition (Final Version)

```java
public interface ChatRepository extends JpaRepository<Chat, UUID> {

    @Query("""
        SELECT c FROM Chat c
        JOIN c.participants p
        WHERE p.userId = :userId
    """)
    List<Chat> findAllByUserId(UUID userId);

    @Query("""
        SELECT c FROM Chat c
        JOIN c.participants p1
        JOIN c.participants p2
        WHERE c.type = 'DIRECT'
          AND p1.userId = :u1
          AND p2.userId = :u2
    """)
    Optional<Chat> findDirectChatBetweenUsers(UUID u1, UUID u2);
}

```

---

## 1. Purpose of ChatRepository

The repository encapsulates all database logic for:

### ✔ retrieving user chats

(`findAllByUserId`)

### ✔ checking whether a direct chat already exists

(`findDirectChatBetweenUsers`)

### ✔ integrating with service layer cleanly

`ChatService` delegates all persistence logic to this repository.

The design ensures:
- clean responsibility boundaries
- easy unit testing via mocked repository
- zero SQL in service/controller layers

---

## 2. Method Documentation (Final Set)

---

### 2.1 `findAllByUserId(UUID userId)`

#### ✔ Purpose

Returns **all chats** where the given user is a participant.

#### ✔ Used for
- chat list sidebar,
- "my chats" listings,
- conversation screen initialization.

#### ✔ JPQL logic

```sql
SELECT c
FROM Chat c
JOIN c.participants p
WHERE p.userId = :userId
```

#### ✔ Notes

This is the *cleanest and idiomatic* way to load chats for a user, because it uses mapped relations:
- `Chat → participants`
- `ChatParticipant → userId`

---

### 2.2 `findDirectChatBetweenUsers(UUID u1, UUID u2)`

#### ✔ Purpose

Checks whether a **direct 1-to-1 chat already exists** between two users.

This prevents creating duplicate direct chats:

❌ Chat A↔B
❌ Another Chat B↔A

✔ Only one unique direct chat per user pair.

#### ✔ Used directly in:

`ChatService#createDirectChat(...)`

#### JPQL logic

```sql
SELECT c
FROM Chat c
JOIN c.participants p1
JOIN c.participants p2
WHERE c.type = 'DIRECT'
  AND p1.userId = :u1
  AND p2.userId = :u2
```

✔ Why use entity navigation (`c.participants`)?
- cleaner, 
- less error-prone,
- safer against schema changes,
- preferred JPA/Hibernate style.

---

## 3. Removed Methods (Cleanup)

The original version contained several unused or duplicate queries.

| Method                                                       | Status      | Why removed                                                         |
|:-------------------------------------------------------------|:------------|:--------------------------------------------------------------------|
| `findAllChatsForUser(UUID)`                                  | ❌ removed   | Duplicate of `findAllByUserId` , harder to read                     |
| `findDirectChat(UUID, UUID)`                                 | ❌ removed   | Not used anywhere, less idiomatic than `findDirectChatBetweenUsers` |
| `deleteByChatIdAndUserId(...)` (in wrong repository earlier) | ❌ removed   | Belongs to ChatParticipantRepository if ever needed                 |

Keeping only the minimal set prevents:
- dead code,
- maintenance overhead,
- confusion for future developers.

---

## 4. Integration with ChatService

Example usage:

```java
public Chat createDirectChat(UUID u1, UUID u2) {

    Optional<Chat> existing =
            chatRepository.findDirectChatBetweenUsers(u1, u2);

    if (existing.isPresent()) {
        return existing.get();
    }

    // create new chat...
}
```

`ChatService` relies entirely on repository methods and does not construct JPQL manually - ensuring clean separation of 
concerns.

---

## 5. Testing Considerations

When unit-testing `ChatService`, repository methods should be mocked:

```java
when(chatRepository.findDirectChatBetweenUsers(u1, u2))
        .thenReturn(Optional.empty());
```

For integration test:
- `@DataJpaTest`
- Testcontainers for PostgreSQL
- verify JPQL queries work as expected

---

## 6. Future Enhancements

Possibly add:

### 1. Paginated chat lists

```java
Page<Chat> findAllByUserId(UUID userId, Pageable pageable);
```

### 2. Search queries

(e.g., by chat name or participant username)

### 3. Chat metadata joins

(e.g., unread counts per user)

### 4. Soft delete / archived chats

(e.g., `archived = true` flag)

---

## ✔ Summary

`ChatRepository` is a clean, minimal, production-ready JPA repository providing essential persistence operations for 
chat rooms.

It includes:

- ✔ retrieving all chats for a user
- ✔ detecting existing direct chats
- ✔ efficient JPQL queries using entity relationships
- ✔ no dead code
- ✔ clear, maintainable API

This repository forms a critical part of the real-time chat backend architecture.